{"ast":null,"code":"/**\n * A set of all the parents currently being observe. This is the only non weak\n * registry.\n */\nconst parents = new Set();\n/**\n * Element coordinates that is constantly kept up to date.\n */\n\nconst coords = new WeakMap();\n/**\n * Siblings of elements that have been removed from the dom.\n */\n\nconst siblings = new WeakMap();\n/**\n * Animations that are currently running.\n */\n\nconst animations = new WeakMap();\n/**\n * A map of existing intersection observers used to track element movements.\n */\n\nconst intersections = new WeakMap();\n/**\n * Intervals for automatically checking the position of elements occasionally.\n */\n\nconst intervals = new WeakMap();\n/**\n * The configuration options for each group of elements.\n */\n\nconst options = new WeakMap();\n/**\n * Debounce counters by id, used to debounce calls to update positions.\n */\n\nconst debounces = new WeakMap();\n/**\n * The document used to calculate transitions.\n */\n\nlet root;\n/**\n * Used to sign an element as the target.\n */\n\nconst TGT = \"__aa_tgt\";\n/**\n * Used to sign an element as being part of a removal.\n */\n\nconst DEL = \"__aa_del\";\n/**\n * Callback for handling all mutations.\n * @param mutations - A mutation list\n */\n\nconst handleMutations = mutations => {\n  const elements = getElements(mutations); // If elements is \"false\" that means this mutation that should be ignored.\n\n  if (elements) {\n    elements.forEach(el => animate(el));\n  }\n};\n/**\n *\n * @param entries - Elements that have been resized.\n */\n\n\nconst handleResizes = entries => {\n  entries.forEach(entry => {\n    if (entry.target === root) updateAllPos();\n    if (coords.has(entry.target)) updatePos(entry.target);\n  });\n};\n/**\n * Observe this elements position.\n * @param el - The element to observe the position of.\n */\n\n\nfunction observePosition(el) {\n  const oldObserver = intersections.get(el);\n  oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();\n  let rect = coords.get(el);\n  let invocations = 0;\n  const buffer = 5;\n\n  if (!rect) {\n    rect = getCoords(el);\n    coords.set(el, rect);\n  }\n\n  const {\n    offsetWidth,\n    offsetHeight\n  } = root;\n  const rootMargins = [rect.top - buffer, offsetWidth - (rect.left + buffer + rect.width), offsetHeight - (rect.top + buffer + rect.height), rect.left - buffer];\n  const rootMargin = rootMargins.map(px => `${-1 * Math.floor(px)}px`).join(\" \");\n  const observer = new IntersectionObserver(() => {\n    ++invocations > 1 && updatePos(el);\n  }, {\n    root,\n    threshold: 1,\n    rootMargin\n  });\n  observer.observe(el);\n  intersections.set(el, observer);\n}\n/**\n * Update the exact position of a given element.\n * @param el - An element to update the position of.\n */\n\n\nfunction updatePos(el) {\n  clearTimeout(debounces.get(el));\n  const optionsOrPlugin = getOptions(el);\n  const delay = typeof optionsOrPlugin === \"function\" ? 500 : optionsOrPlugin.duration;\n  debounces.set(el, setTimeout(() => {\n    const currentAnimation = animations.get(el);\n\n    if (!currentAnimation || currentAnimation.finished) {\n      coords.set(el, getCoords(el));\n      observePosition(el);\n    }\n  }, delay));\n}\n/**\n * Updates all positions that are currently being tracked.\n */\n\n\nfunction updateAllPos() {\n  clearTimeout(debounces.get(root));\n  debounces.set(root, setTimeout(() => {\n    parents.forEach(parent => forEach(parent, el => lowPriority(() => updatePos(el))));\n  }, 100));\n}\n/**\n * Its possible for a quick scroll or other fast events to get past the\n * intersection observer, so occasionally we need want \"cold-poll\" for the\n * latests and greatest position. We try to do this in the most non-disruptive\n * fashion possible. First we only do this ever couple seconds, staggard by a\n * random offset.\n * @param el - Element\n */\n\n\nfunction poll(el) {\n  setTimeout(() => {\n    intervals.set(el, setInterval(() => lowPriority(updatePos.bind(null, el)), 2000));\n  }, Math.round(2000 * Math.random()));\n}\n/**\n * Perform some operation that is non critical at some point.\n * @param callback\n */\n\n\nfunction lowPriority(callback) {\n  if (typeof requestIdleCallback === \"function\") {\n    requestIdleCallback(() => callback());\n  } else {\n    requestAnimationFrame(() => callback());\n  }\n}\n/**\n * The mutation observer responsible for watching each root element.\n */\n\n\nlet mutations;\n/**\n * A resize observer, responsible for recalculating elements on resize.\n */\n\nlet resize;\n/**\n * If this is in a browser, initialize our Web APIs\n */\n\nif (typeof window !== \"undefined\") {\n  root = document.documentElement;\n  mutations = new MutationObserver(handleMutations);\n  resize = new ResizeObserver(handleResizes);\n  resize.observe(root);\n}\n/**\n * Retrieves all the elements that may have been affected by the last mutation\n * including ones that have been removed and are no longer in the DOM.\n * @param mutations - A mutation list.\n * @returns\n */\n\n\nfunction getElements(mutations) {\n  return mutations.reduce((elements, mutation) => {\n    // Short circuit if we find a purposefully deleted node.\n    if (elements === false) return false;\n\n    if (mutation.target instanceof Element) {\n      target(mutation.target);\n\n      if (!elements.has(mutation.target)) {\n        elements.add(mutation.target);\n\n        for (let i = 0; i < mutation.target.children.length; i++) {\n          const child = mutation.target.children.item(i);\n          if (!child) continue;\n          if (DEL in child) return false;\n          target(mutation.target, child);\n          elements.add(child);\n        }\n      }\n\n      if (mutation.removedNodes.length) {\n        for (let i = 0; i < mutation.removedNodes.length; i++) {\n          const child = mutation.removedNodes[i];\n          if (DEL in child) return false;\n\n          if (child instanceof Element) {\n            elements.add(child);\n            target(mutation.target, child);\n            siblings.set(child, [mutation.previousSibling, mutation.nextSibling]);\n          }\n        }\n      }\n    }\n\n    return elements;\n  }, new Set());\n}\n/**\n *\n * @param el - The root element\n * @param child\n */\n\n\nfunction target(el, child) {\n  if (!child && !(TGT in el)) Object.defineProperty(el, TGT, {\n    value: el\n  });else if (child && !(TGT in child)) Object.defineProperty(child, TGT, {\n    value: el\n  });\n}\n/**\n * Determines what kind of change took place on the given element and then\n * performs the proper animation based on that.\n * @param el - The specific element to animate.\n */\n\n\nfunction animate(el) {\n  var _a;\n\n  const isMounted = root.contains(el);\n  const preExisting = coords.has(el);\n  if (isMounted && siblings.has(el)) siblings.delete(el);\n\n  if (animations.has(el)) {\n    (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();\n  }\n\n  if (preExisting && isMounted) {\n    remain(el);\n  } else if (preExisting && !isMounted) {\n    remove(el);\n  } else {\n    add(el);\n  }\n}\n/**\n * Removes all non-digits from a string and casts to a number.\n * @param str - A string containing a pixel value.\n * @returns\n */\n\n\nfunction raw(str) {\n  return Number(str.replace(/[^0-9.\\-]/g, \"\"));\n}\n/**\n * Get the coordinates of elements adjusted for scroll position.\n * @param el - Element\n * @returns\n */\n\n\nfunction getCoords(el) {\n  const rect = el.getBoundingClientRect();\n  return {\n    top: rect.top + window.scrollY,\n    left: rect.left + window.scrollX,\n    width: rect.width,\n    height: rect.height\n  };\n}\n/**\n * Returns the width/height that the element should be transitioned between.\n * This takes into account box-sizing.\n * @param el - Element being animated\n * @param oldCoords - Old set of Coordinates coordinates\n * @param newCoords - New set of Coordinates coordinates\n * @returns\n */\n\n\nfunction getTransitionSizes(el, oldCoords, newCoords) {\n  let widthFrom = oldCoords.width;\n  let heightFrom = oldCoords.height;\n  let widthTo = newCoords.width;\n  let heightTo = newCoords.height;\n  const styles = getComputedStyle(el);\n  const sizing = styles.getPropertyValue(\"box-sizing\");\n\n  if (sizing === \"content-box\") {\n    const paddingY = raw(styles.paddingTop) + raw(styles.paddingBottom) + raw(styles.borderTopWidth) + raw(styles.borderBottomWidth);\n    const paddingX = raw(styles.paddingLeft) + raw(styles.paddingRight) + raw(styles.borderRightWidth) + raw(styles.borderLeftWidth);\n    widthFrom -= paddingX;\n    widthTo -= paddingX;\n    heightFrom -= paddingY;\n    heightTo -= paddingY;\n  }\n\n  return [widthFrom, widthTo, heightFrom, heightTo].map(Math.round);\n}\n/**\n * Retrieves animation options for the current element.\n * @param el - Element to retrieve options for.\n * @returns\n */\n\n\nfunction getOptions(el) {\n  return TGT in el && options.has(el[TGT]) ? options.get(el[TGT]) : {\n    duration: 250,\n    easing: \"ease-in-out\"\n  };\n}\n/**\n * Iterate over the children of a given parent.\n * @param parent - A parent element\n * @param callback - A callback\n */\n\n\nfunction forEach(parent) {\n  for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    callbacks[_key - 1] = arguments[_key];\n  }\n\n  callbacks.forEach(callback => callback(parent, options.has(parent)));\n\n  for (let i = 0; i < parent.children.length; i++) {\n    const child = parent.children.item(i);\n\n    if (child) {\n      callbacks.forEach(callback => callback(child, options.has(child)));\n    }\n  }\n}\n/**\n * The element in question is remaining in the DOM.\n * @param el - Element to flip\n * @returns\n */\n\n\nfunction remain(el) {\n  const oldCoords = coords.get(el);\n  const newCoords = getCoords(el);\n  let animation;\n  if (!oldCoords) return;\n  const pluginOrOptions = getOptions(el);\n\n  if (typeof pluginOrOptions !== \"function\") {\n    const deltaX = oldCoords.left - newCoords.left;\n    const deltaY = oldCoords.top - newCoords.top;\n    const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);\n    const start = {\n      transform: `translate(${deltaX}px, ${deltaY}px)`\n    };\n    const end = {\n      transform: `translate(0, 0)`\n    };\n\n    if (widthFrom !== widthTo) {\n      start.width = `${widthFrom}px`;\n      end.width = `${widthTo}px`;\n    }\n\n    if (heightFrom !== heightTo) {\n      start.height = `${heightFrom}px`;\n      end.height = `${heightTo}px`;\n    }\n\n    animation = el.animate([start, end], pluginOrOptions);\n  } else {\n    animation = new Animation(pluginOrOptions(el, \"remain\", oldCoords, newCoords));\n    animation.play();\n  }\n\n  animations.set(el, animation);\n  coords.set(el, newCoords);\n  animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Adds the element with a transition.\n * @param el - Animates the element being added.\n */\n\n\nfunction add(el) {\n  const newCoords = getCoords(el);\n  coords.set(el, newCoords);\n  const pluginOrOptions = getOptions(el);\n  let animation;\n\n  if (typeof pluginOrOptions !== \"function\") {\n    animation = el.animate([{\n      transform: \"scale(.98)\",\n      opacity: 0\n    }, {\n      transform: \"scale(0.98)\",\n      opacity: 0,\n      offset: 0.5\n    }, {\n      transform: \"scale(1)\",\n      opacity: 1\n    }], {\n      duration: pluginOrOptions.duration * 1.5,\n      easing: \"ease-in\"\n    });\n  } else {\n    animation = new Animation(pluginOrOptions(el, \"add\", newCoords));\n    animation.play();\n  }\n\n  animations.set(el, animation);\n  animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Animates the removal of an element.\n * @param el - Element to remove\n */\n\n\nfunction remove(el) {\n  if (!siblings.has(el) || !coords.has(el)) return;\n  const [prev, next] = siblings.get(el);\n  Object.defineProperty(el, DEL, {\n    value: true\n  });\n\n  if (next && next.parentNode && next.parentNode instanceof Element) {\n    next.parentNode.insertBefore(el, next);\n  } else if (prev && prev.parentNode) {\n    prev.parentNode.appendChild(el);\n  }\n\n  const [top, left, width, height] = deletePosition(el);\n  const optionsOrPlugin = getOptions(el);\n  const oldCoords = coords.get(el);\n  let animation;\n  Object.assign(el.style, {\n    position: \"absolute\",\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    margin: 0,\n    pointerEvents: \"none\",\n    transformOrigin: \"center\",\n    zIndex: 100\n  });\n\n  if (typeof optionsOrPlugin !== \"function\") {\n    animation = el.animate([{\n      transform: \"scale(1)\",\n      opacity: 1\n    }, {\n      transform: \"scale(.98)\",\n      opacity: 0\n    }], {\n      duration: optionsOrPlugin.duration,\n      easing: \"ease-out\"\n    });\n  } else {\n    animation = new Animation(optionsOrPlugin(el, \"remove\", oldCoords));\n    animation.play();\n  }\n\n  animations.set(el, animation);\n  animation.addEventListener(\"finish\", () => {\n    var _a;\n\n    el.remove();\n    coords.delete(el);\n    siblings.delete(el);\n    animations.delete(el);\n    (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();\n  });\n}\n\nfunction deletePosition(el) {\n  const oldCoords = coords.get(el);\n  const [width,, height] = getTransitionSizes(el, oldCoords, getCoords(el));\n  let offsetParent = el.parentElement;\n\n  while (offsetParent && (getComputedStyle(offsetParent).position === \"static\" || offsetParent instanceof HTMLBodyElement)) {\n    offsetParent = offsetParent.parentElement;\n  }\n\n  if (!offsetParent) offsetParent = document.body;\n  const parentStyles = getComputedStyle(offsetParent);\n  const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);\n  const top = Math.round(oldCoords.top - parentCoords.top) - raw(parentStyles.borderTopWidth);\n  const left = Math.round(oldCoords.left - parentCoords.left) - raw(parentStyles.borderLeftWidth);\n  return [top, left, width, height];\n}\n/**\n * A function that automatically adds animation effects to itself and its\n * immediate children. Specifically it adds effects for adding, moving, and\n * removing DOM elements.\n * @param el - A parent element to add animations to.\n * @param options - An optional object of options.\n */\n\n\nfunction autoAnimate(el) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (mutations && resize) {\n    const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n    if (mediaQuery.matches) return;\n\n    if (getComputedStyle(el).position === \"static\") {\n      Object.assign(el.style, {\n        position: \"relative\"\n      });\n    }\n\n    forEach(el, updatePos, poll, element => resize === null || resize === void 0 ? void 0 : resize.observe(element));\n\n    if (typeof config === \"function\") {\n      options.set(el, config);\n    } else {\n      options.set(el, {\n        duration: 250,\n        easing: \"ease-in-out\",\n        ...config\n      });\n    }\n\n    mutations.observe(el, {\n      childList: true\n    });\n    parents.add(el);\n  }\n}\n/**\n * The vue directive.\n */\n\n\nconst vAutoAnimate = {\n  mounted: (el, binding) => {\n    autoAnimate(el, binding.value || {});\n  }\n};\nexport { autoAnimate as default, getTransitionSizes, vAutoAnimate };","map":{"version":3,"names":["parents","Set","coords","WeakMap","siblings","animations","intersections","intervals","options","debounces","root","TGT","DEL","handleMutations","mutations","elements","getElements","forEach","el","animate","handleResizes","entries","entry","target","updateAllPos","has","updatePos","observePosition","oldObserver","get","disconnect","rect","invocations","buffer","getCoords","set","offsetWidth","offsetHeight","rootMargins","top","left","width","height","rootMargin","map","px","Math","floor","join","observer","IntersectionObserver","threshold","observe","clearTimeout","optionsOrPlugin","getOptions","delay","duration","setTimeout","currentAnimation","finished","parent","lowPriority","poll","setInterval","bind","round","random","callback","requestIdleCallback","requestAnimationFrame","resize","window","document","documentElement","MutationObserver","ResizeObserver","reduce","mutation","Element","add","i","children","length","child","item","removedNodes","previousSibling","nextSibling","Object","defineProperty","value","_a","isMounted","contains","preExisting","delete","cancel","remain","remove","raw","str","Number","replace","getBoundingClientRect","scrollY","scrollX","getTransitionSizes","oldCoords","newCoords","widthFrom","heightFrom","widthTo","heightTo","styles","getComputedStyle","sizing","getPropertyValue","paddingY","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","paddingX","paddingLeft","paddingRight","borderRightWidth","borderLeftWidth","easing","callbacks","animation","pluginOrOptions","deltaX","deltaY","start","transform","end","Animation","play","addEventListener","opacity","offset","prev","next","parentNode","insertBefore","appendChild","deletePosition","assign","style","position","margin","pointerEvents","transformOrigin","zIndex","offsetParent","parentElement","HTMLBodyElement","body","parentStyles","parentCoords","autoAnimate","config","mediaQuery","matchMedia","matches","element","childList","vAutoAnimate","mounted","binding","default"],"sources":["C:/Users/quand/OneDrive/Máy tính/F8/AmazonStarterPack/node_modules/@formkit/auto-animate/index.mjs"],"sourcesContent":["/**\n * A set of all the parents currently being observe. This is the only non weak\n * registry.\n */\nconst parents = new Set();\n/**\n * Element coordinates that is constantly kept up to date.\n */\nconst coords = new WeakMap();\n/**\n * Siblings of elements that have been removed from the dom.\n */\nconst siblings = new WeakMap();\n/**\n * Animations that are currently running.\n */\nconst animations = new WeakMap();\n/**\n * A map of existing intersection observers used to track element movements.\n */\nconst intersections = new WeakMap();\n/**\n * Intervals for automatically checking the position of elements occasionally.\n */\nconst intervals = new WeakMap();\n/**\n * The configuration options for each group of elements.\n */\nconst options = new WeakMap();\n/**\n * Debounce counters by id, used to debounce calls to update positions.\n */\nconst debounces = new WeakMap();\n/**\n * The document used to calculate transitions.\n */\nlet root;\n/**\n * Used to sign an element as the target.\n */\nconst TGT = \"__aa_tgt\";\n/**\n * Used to sign an element as being part of a removal.\n */\nconst DEL = \"__aa_del\";\n/**\n * Callback for handling all mutations.\n * @param mutations - A mutation list\n */\nconst handleMutations = (mutations) => {\n    const elements = getElements(mutations);\n    // If elements is \"false\" that means this mutation that should be ignored.\n    if (elements) {\n        elements.forEach((el) => animate(el));\n    }\n};\n/**\n *\n * @param entries - Elements that have been resized.\n */\nconst handleResizes = (entries) => {\n    entries.forEach((entry) => {\n        if (entry.target === root)\n            updateAllPos();\n        if (coords.has(entry.target))\n            updatePos(entry.target);\n    });\n};\n/**\n * Observe this elements position.\n * @param el - The element to observe the position of.\n */\nfunction observePosition(el) {\n    const oldObserver = intersections.get(el);\n    oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();\n    let rect = coords.get(el);\n    let invocations = 0;\n    const buffer = 5;\n    if (!rect) {\n        rect = getCoords(el);\n        coords.set(el, rect);\n    }\n    const { offsetWidth, offsetHeight } = root;\n    const rootMargins = [\n        rect.top - buffer,\n        offsetWidth - (rect.left + buffer + rect.width),\n        offsetHeight - (rect.top + buffer + rect.height),\n        rect.left - buffer,\n    ];\n    const rootMargin = rootMargins\n        .map((px) => `${-1 * Math.floor(px)}px`)\n        .join(\" \");\n    const observer = new IntersectionObserver(() => {\n        ++invocations > 1 && updatePos(el);\n    }, {\n        root,\n        threshold: 1,\n        rootMargin,\n    });\n    observer.observe(el);\n    intersections.set(el, observer);\n}\n/**\n * Update the exact position of a given element.\n * @param el - An element to update the position of.\n */\nfunction updatePos(el) {\n    clearTimeout(debounces.get(el));\n    const optionsOrPlugin = getOptions(el);\n    const delay = typeof optionsOrPlugin === \"function\" ? 500 : optionsOrPlugin.duration;\n    debounces.set(el, setTimeout(() => {\n        const currentAnimation = animations.get(el);\n        if (!currentAnimation || currentAnimation.finished) {\n            coords.set(el, getCoords(el));\n            observePosition(el);\n        }\n    }, delay));\n}\n/**\n * Updates all positions that are currently being tracked.\n */\nfunction updateAllPos() {\n    clearTimeout(debounces.get(root));\n    debounces.set(root, setTimeout(() => {\n        parents.forEach((parent) => forEach(parent, (el) => lowPriority(() => updatePos(el))));\n    }, 100));\n}\n/**\n * Its possible for a quick scroll or other fast events to get past the\n * intersection observer, so occasionally we need want \"cold-poll\" for the\n * latests and greatest position. We try to do this in the most non-disruptive\n * fashion possible. First we only do this ever couple seconds, staggard by a\n * random offset.\n * @param el - Element\n */\nfunction poll(el) {\n    setTimeout(() => {\n        intervals.set(el, setInterval(() => lowPriority(updatePos.bind(null, el)), 2000));\n    }, Math.round(2000 * Math.random()));\n}\n/**\n * Perform some operation that is non critical at some point.\n * @param callback\n */\nfunction lowPriority(callback) {\n    if (typeof requestIdleCallback === \"function\") {\n        requestIdleCallback(() => callback());\n    }\n    else {\n        requestAnimationFrame(() => callback());\n    }\n}\n/**\n * The mutation observer responsible for watching each root element.\n */\nlet mutations;\n/**\n * A resize observer, responsible for recalculating elements on resize.\n */\nlet resize;\n/**\n * If this is in a browser, initialize our Web APIs\n */\nif (typeof window !== \"undefined\") {\n    root = document.documentElement;\n    mutations = new MutationObserver(handleMutations);\n    resize = new ResizeObserver(handleResizes);\n    resize.observe(root);\n}\n/**\n * Retrieves all the elements that may have been affected by the last mutation\n * including ones that have been removed and are no longer in the DOM.\n * @param mutations - A mutation list.\n * @returns\n */\nfunction getElements(mutations) {\n    return mutations.reduce((elements, mutation) => {\n        // Short circuit if we find a purposefully deleted node.\n        if (elements === false)\n            return false;\n        if (mutation.target instanceof Element) {\n            target(mutation.target);\n            if (!elements.has(mutation.target)) {\n                elements.add(mutation.target);\n                for (let i = 0; i < mutation.target.children.length; i++) {\n                    const child = mutation.target.children.item(i);\n                    if (!child)\n                        continue;\n                    if (DEL in child)\n                        return false;\n                    target(mutation.target, child);\n                    elements.add(child);\n                }\n            }\n            if (mutation.removedNodes.length) {\n                for (let i = 0; i < mutation.removedNodes.length; i++) {\n                    const child = mutation.removedNodes[i];\n                    if (DEL in child)\n                        return false;\n                    if (child instanceof Element) {\n                        elements.add(child);\n                        target(mutation.target, child);\n                        siblings.set(child, [\n                            mutation.previousSibling,\n                            mutation.nextSibling,\n                        ]);\n                    }\n                }\n            }\n        }\n        return elements;\n    }, new Set());\n}\n/**\n *\n * @param el - The root element\n * @param child\n */\nfunction target(el, child) {\n    if (!child && !(TGT in el))\n        Object.defineProperty(el, TGT, { value: el });\n    else if (child && !(TGT in child))\n        Object.defineProperty(child, TGT, { value: el });\n}\n/**\n * Determines what kind of change took place on the given element and then\n * performs the proper animation based on that.\n * @param el - The specific element to animate.\n */\nfunction animate(el) {\n    var _a;\n    const isMounted = root.contains(el);\n    const preExisting = coords.has(el);\n    if (isMounted && siblings.has(el))\n        siblings.delete(el);\n    if (animations.has(el)) {\n        (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();\n    }\n    if (preExisting && isMounted) {\n        remain(el);\n    }\n    else if (preExisting && !isMounted) {\n        remove(el);\n    }\n    else {\n        add(el);\n    }\n}\n/**\n * Removes all non-digits from a string and casts to a number.\n * @param str - A string containing a pixel value.\n * @returns\n */\nfunction raw(str) {\n    return Number(str.replace(/[^0-9.\\-]/g, \"\"));\n}\n/**\n * Get the coordinates of elements adjusted for scroll position.\n * @param el - Element\n * @returns\n */\nfunction getCoords(el) {\n    const rect = el.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        left: rect.left + window.scrollX,\n        width: rect.width,\n        height: rect.height,\n    };\n}\n/**\n * Returns the width/height that the element should be transitioned between.\n * This takes into account box-sizing.\n * @param el - Element being animated\n * @param oldCoords - Old set of Coordinates coordinates\n * @param newCoords - New set of Coordinates coordinates\n * @returns\n */\nfunction getTransitionSizes(el, oldCoords, newCoords) {\n    let widthFrom = oldCoords.width;\n    let heightFrom = oldCoords.height;\n    let widthTo = newCoords.width;\n    let heightTo = newCoords.height;\n    const styles = getComputedStyle(el);\n    const sizing = styles.getPropertyValue(\"box-sizing\");\n    if (sizing === \"content-box\") {\n        const paddingY = raw(styles.paddingTop) +\n            raw(styles.paddingBottom) +\n            raw(styles.borderTopWidth) +\n            raw(styles.borderBottomWidth);\n        const paddingX = raw(styles.paddingLeft) +\n            raw(styles.paddingRight) +\n            raw(styles.borderRightWidth) +\n            raw(styles.borderLeftWidth);\n        widthFrom -= paddingX;\n        widthTo -= paddingX;\n        heightFrom -= paddingY;\n        heightTo -= paddingY;\n    }\n    return [widthFrom, widthTo, heightFrom, heightTo].map(Math.round);\n}\n/**\n * Retrieves animation options for the current element.\n * @param el - Element to retrieve options for.\n * @returns\n */\nfunction getOptions(el) {\n    return TGT in el && options.has(el[TGT])\n        ? options.get(el[TGT])\n        : { duration: 250, easing: \"ease-in-out\" };\n}\n/**\n * Iterate over the children of a given parent.\n * @param parent - A parent element\n * @param callback - A callback\n */\nfunction forEach(parent, ...callbacks) {\n    callbacks.forEach((callback) => callback(parent, options.has(parent)));\n    for (let i = 0; i < parent.children.length; i++) {\n        const child = parent.children.item(i);\n        if (child) {\n            callbacks.forEach((callback) => callback(child, options.has(child)));\n        }\n    }\n}\n/**\n * The element in question is remaining in the DOM.\n * @param el - Element to flip\n * @returns\n */\nfunction remain(el) {\n    const oldCoords = coords.get(el);\n    const newCoords = getCoords(el);\n    let animation;\n    if (!oldCoords)\n        return;\n    const pluginOrOptions = getOptions(el);\n    if (typeof pluginOrOptions !== \"function\") {\n        const deltaX = oldCoords.left - newCoords.left;\n        const deltaY = oldCoords.top - newCoords.top;\n        const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);\n        const start = {\n            transform: `translate(${deltaX}px, ${deltaY}px)`,\n        };\n        const end = {\n            transform: `translate(0, 0)`,\n        };\n        if (widthFrom !== widthTo) {\n            start.width = `${widthFrom}px`;\n            end.width = `${widthTo}px`;\n        }\n        if (heightFrom !== heightTo) {\n            start.height = `${heightFrom}px`;\n            end.height = `${heightTo}px`;\n        }\n        animation = el.animate([start, end], pluginOrOptions);\n    }\n    else {\n        animation = new Animation(pluginOrOptions(el, \"remain\", oldCoords, newCoords));\n        animation.play();\n    }\n    animations.set(el, animation);\n    coords.set(el, newCoords);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Adds the element with a transition.\n * @param el - Animates the element being added.\n */\nfunction add(el) {\n    const newCoords = getCoords(el);\n    coords.set(el, newCoords);\n    const pluginOrOptions = getOptions(el);\n    let animation;\n    if (typeof pluginOrOptions !== \"function\") {\n        animation = el.animate([\n            { transform: \"scale(.98)\", opacity: 0 },\n            { transform: \"scale(0.98)\", opacity: 0, offset: 0.5 },\n            { transform: \"scale(1)\", opacity: 1 },\n        ], {\n            duration: pluginOrOptions.duration * 1.5,\n            easing: \"ease-in\",\n        });\n    }\n    else {\n        animation = new Animation(pluginOrOptions(el, \"add\", newCoords));\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Animates the removal of an element.\n * @param el - Element to remove\n */\nfunction remove(el) {\n    if (!siblings.has(el) || !coords.has(el))\n        return;\n    const [prev, next] = siblings.get(el);\n    Object.defineProperty(el, DEL, { value: true });\n    if (next && next.parentNode && next.parentNode instanceof Element) {\n        next.parentNode.insertBefore(el, next);\n    }\n    else if (prev && prev.parentNode) {\n        prev.parentNode.appendChild(el);\n    }\n    const [top, left, width, height] = deletePosition(el);\n    const optionsOrPlugin = getOptions(el);\n    const oldCoords = coords.get(el);\n    let animation;\n    Object.assign(el.style, {\n        position: \"absolute\",\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        margin: 0,\n        pointerEvents: \"none\",\n        transformOrigin: \"center\",\n        zIndex: 100,\n    });\n    if (typeof optionsOrPlugin !== \"function\") {\n        animation = el.animate([\n            {\n                transform: \"scale(1)\",\n                opacity: 1,\n            },\n            {\n                transform: \"scale(.98)\",\n                opacity: 0,\n            },\n        ], { duration: optionsOrPlugin.duration, easing: \"ease-out\" });\n    }\n    else {\n        animation = new Animation(optionsOrPlugin(el, \"remove\", oldCoords));\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", () => {\n        var _a;\n        el.remove();\n        coords.delete(el);\n        siblings.delete(el);\n        animations.delete(el);\n        (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();\n    });\n}\nfunction deletePosition(el) {\n    const oldCoords = coords.get(el);\n    const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));\n    let offsetParent = el.parentElement;\n    while (offsetParent &&\n        (getComputedStyle(offsetParent).position === \"static\" ||\n            offsetParent instanceof HTMLBodyElement)) {\n        offsetParent = offsetParent.parentElement;\n    }\n    if (!offsetParent)\n        offsetParent = document.body;\n    const parentStyles = getComputedStyle(offsetParent);\n    const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);\n    const top = Math.round(oldCoords.top - parentCoords.top) -\n        raw(parentStyles.borderTopWidth);\n    const left = Math.round(oldCoords.left - parentCoords.left) -\n        raw(parentStyles.borderLeftWidth);\n    return [top, left, width, height];\n}\n/**\n * A function that automatically adds animation effects to itself and its\n * immediate children. Specifically it adds effects for adding, moving, and\n * removing DOM elements.\n * @param el - A parent element to add animations to.\n * @param options - An optional object of options.\n */\nfunction autoAnimate(el, config = {}) {\n    if (mutations && resize) {\n        const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n        if (mediaQuery.matches)\n            return;\n        if (getComputedStyle(el).position === \"static\") {\n            Object.assign(el.style, { position: \"relative\" });\n        }\n        forEach(el, updatePos, poll, (element) => resize === null || resize === void 0 ? void 0 : resize.observe(element));\n        if (typeof config === \"function\") {\n            options.set(el, config);\n        }\n        else {\n            options.set(el, { duration: 250, easing: \"ease-in-out\", ...config });\n        }\n        mutations.observe(el, { childList: true });\n        parents.add(el);\n    }\n}\n/**\n * The vue directive.\n */\nconst vAutoAnimate = {\n    mounted: (el, binding) => {\n        autoAnimate(el, binding.value || {});\n    },\n};\n\nexport { autoAnimate as default, getTransitionSizes, vAutoAnimate };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}